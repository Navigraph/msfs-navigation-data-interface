# Developer-Oriented In-Sim Navigation Data API Specification

To be Reviewed By: Markus Hamburger, Malte Hallstr√∂m, Jack Lavigne

Authors: Alex Cutforth

Status: Discussion

## Problem

Accessing Navigraph's navdata in Microsoft Flight Simulator has always been challenging due to the limitations of the JavaScript and Webassembly APIs. However, with the recent addition of the Communications API, allowing different WASM modules and Coherent pages to interact with each other, this has become possible.

Navigraph has decided to use an architecture consisting of a wasm module whose job it is to download navdata databases from the internet, and to query them. This means an API must be designed and implemented to best cater to the needs of aircraft developers.

This RFC will outline the following:

- Naming, typing, and other standards to use throughout the API
- Example data structures for the returned data which are comprehensive and ergonomic to use
- Example functions the API will implement to provide the necessary data.

## Anti-Goals

This interface will not be designed for use in parallel with in sim data, it is meant to provide the best experience possible with Navigraph's navdata capabilities. This interface will only be providing data from Navigraph's databases.

This interface is also not designed for use outside of Microsoft Flight Simulator and is not designed (as of now) with anything other than the Flight Management System in mind.

# Solution

## Standards

---

- The data released JS side should use `camelCase`, but in rust they can be `snake_case`. This conversion should happen JS side so that other wasm modules which use the data have snake_case
- Data fields which act as an identifier should always use the shorthand term: `ident` and should not name the type they are part of.
  - Example: Runways may contain the fields:
    - `ident: "RW23L"`
    - `airportIdent: "NZAA"`
  - Example: Airports may contain the field:
    - `ident: "NZAA"`
- Using the term `icao` to refer to an identifier is an anti-pattern as it may be confused with the `icaoCode` which contains a two-letter code such as `ES` which represents the area of the world where this piece of data lies.
  - Example: Airports may contain the fields:
    - `icaoCode: "NZ"`
    - `ident: "NZAA"`
- Fields should represent the unit that the data will be using a type alias, not by a suffix or prefix to the name of the field.
  - Do: `runwayLength: Feet`
  - Don't: `runwayLengthFt: number`
- Radio navigation aid data type names should consist of the acronym of the type, followed by the suffix `Navaid`
  - Examples: `VhfNavaid`, `IlsNavaid`, `NdbNavaid`,
- Acronyms should **_not_** be all capitalised
  - Do: `Vhf`
  - Dont: `NDB`
- Latitudes should be encoded to as `lat` and Longitudes should be encoded to as `long`, and should wherever they are used in conjunction with each other, be part of a `Coordinates` data structure

---

- Items which are linked to other data should **_not_** have the linked data queried automatically and added to the returned data.
  - This is because increasing the size of data this much will result in slower queries due to the performance issues with Coherent's JSON parser.
  - While it is useful to have linked data such as Navaid information on airway or procedures, this would not be viable when using the API in a language other than JS or Rust
- For items such as Procedures and Airways, which are represented in the database as a large number of rows with the same `ident` and possibly `icaoCode`. They should be grouped into an object, containing list(s) which stores the individual elements. Fields which are known to be the same throughout the grouping should be on the group object, not the individual elements.
  - If the individual elements are split into sections such as transitions in a procedure, these should be encoded as subgroups.

---

- Data should be provided in the same units that the Database provides for consistency with aviation standards
- Enums should be used where possible and should have values which match the database encoding.
  - Except for when an enum is to be used as a filter, where its values should support bitwise flags.
- The data provided by this API should be able to be encoded purely in JSON, meaning:

  - No functions
  - No classes
  - This is to support JSON serialization as a form of copying or sending between instruments

- Data fields should never be empty strings, they should be undefined
- Data fields which are linked to each other and will either both be undefined or both be defined
- Data being encoded as possibly undefined should be based on database sweeps to find whether there are any null fields, not the database schema.

- Datastructures which are expected to have certain fields be defined based on the value of another field should have the type-system enforce this where possible, for example:

  - Procedure legs will have their fields filtered based upon the `pathTermination` field. Specs for this can be found [here](https://developers.navigraph.com/docs/navigation-data/dfd-data-format#procedure-leg-data-fields-minimum-requirements) or in `ARINC SPECIFICATION 424 Attachment 5 Data fields table 3`
  - Altitude constraints

---

- Functions which fetch items by the identifier should be named as `get{type}s`
- Functions which fetch a list of items by a grouping should be named `get{type}At{group}` and should take in the identifier of the item used as the grouping
- Functions which fetch a list of items by location and range should use the naming: `get{type}InRange`, and should take in:

  - The center coordinates of the query
  - The range in nautical miles to search around the center
  - Any filters necessary for the type being fetched

---

- In the rust implementation, Mapping one row to one output struct should use a From<> implementation, but any other mapping should be done with a descriptively named function

---

## Example Datastructures

These datastructures are for use in JS/TS, however, they should be encoded as close to this as they can be on the WASM side, so minimal computation needs to happen in Coherent.

```ts
export interface Coordinates {
  lat: Degrees
  long: Degrees
}
```

For data which links to a Fix such as Departures, Arrivals, Airways etc should use the Fix interface as the type for those fields. The data in Fix should be obtainable purely from id fields and location field.

The Fix data will be enough information for computing and rendering procedures and airways on most aircraft. After reading the fixType field, full data for the Fix can be fetched using the respective queries.

```ts
export enum FixType {
  Airport,
  NdbNavaid,
  RunwayThreshold,
  GlsNavaid,
  IlsNavaid,
  VhfNavaid,
  Waypoint,
}

interface Fix {
  fixType: FixType
  ident: string
  icaoCode: string
  location: Coordinates
  airportIdentifier?: string
}
```

```ts
interface ProcedureTransition {
  ident: string
  legs: ProcedureLeg[]
}

interface Departure {
  ident: string
  runwayTransitions: ProcedureTransition[]
  commonLegs: ProcedureLeg[]
  enrouteTransitions: ProcedureTransition[]
  engineOutLegs: ProcedureLeg[]
}
```

```ts
export interface Airport {
  areaCode: string
  ident3Letter?: string
  name: string
  ifrCapability: IfrCapability
  elevation: Feet
  transitionAltitude?: Feet
  transitionLevel?: Feet
  speedLimit?: Knots
  speedLimitAltitude?: Feet
  iataIdent?: string
}
```

```ts
export interface Airway {
  ident: string
  fixes: Fix[]
  routeType: RouteType
  level: AirwayLevel
  direction?: AirwayDirection
}
```

## Example API functions

```ts
getAirport(ident: string): Promise<Airport>
getWaypoints(ident: string): Promise<Waypoint[]>
getAirways(ident: string): Promise<Airway[]>

getDeparturesAtAirport(airportIdent: string): Promise<Departure[]>
getCommunicationsAtAirport(airportIdent: string): Promise<AirportCommunication[]>

getAirwaysAtFix(fixIdent: string, fixIcaoCode: string): Promise<Airway[]>

getWaypointsInRange(center: Coordinates, range: NauticalMiles, area?: Area): Promise<Waypoint[]>
getAirwaysInRange(center: Coordinates, range: NauticalMiles, level?: AirwayLevel): Promise<Airway[]>
```
